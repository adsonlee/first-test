<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å°å­¦ç”Ÿè¿·å®«å¤§å†’é™© - éš¾åº¦å‡çº§ç‰ˆ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <!-- é…ç½®Tailwindè‡ªå®šä¹‰æ ·å¼ -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#FF6B6B',
                        secondary: '#4ECDC4',
                        light: '#F7FFF7',
                        dark: '#1A535C',
                        maze: '#FFE66D',
                        obstacle: '#FF9F1C'
                    },
                    fontFamily: {
                        comic: ['Comic Sans MS', 'Marker Felt', 'sans-serif']
                    }
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .btn-shadow {
                box-shadow: 0 4px 0 #1A535C, 0 6px 10px rgba(0,0,0,0.2);
            }
            .btn-active {
                transform: translateY(4px);
                box-shadow: 0 2px 0 #1A535C, 0 4px 6px rgba(0,0,0,0.2);
            }
            .maze-border {
                border-image: linear-gradient(to right, #FF6B6B, #4ECDC4) 1;
            }
            .vision-weak {
                filter: brightness(0.9) contrast(0.9) blur(0.5px);
            }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-light to-secondary min-h-screen font-comic text-dark flex flex-col items-center justify-start p-4 md:p-8">
    <!-- æ¸¸æˆæ ‡é¢˜ -->
    <header class="text-center mb-6 w-full">
        <h1 class="text-[clamp(2rem,5vw,3.5rem)] font-bold text-primary drop-shadow-lg mb-2">è¿·å®«å¤§å†’é™©</h1>
        <p class="text-[clamp(1rem,2vw,1.2rem)] text-dark/80">å¸®åŠ©å°ç¬‘è„¸æ‰¾åˆ°å‡ºå£å§ï¼<span class="text-primary">æ–¹å‘é”®/è™šæ‹ŸæŒ‰é’®ç§»åŠ¨</span></p>
        <p id="difficultyTip" class="text-sm text-obstacle font-bold mt-2">å½“å‰éš¾åº¦ï¼šä¸­ç­‰ - æ™®é€šè¿·å®«ï¼Œæ— é™åˆ¶</p>
    </header>

    <!-- æ¸¸æˆæ§åˆ¶é¢æ¿ -->
    <div class="flex flex-wrap justify-center items-center gap-4 mb-6 w-full max-w-3xl">
        <div class="bg-white/80 rounded-lg p-3 shadow-md flex items-center gap-3">
            <label class="font-bold">éš¾åº¦ï¼š</label>
            <select id="difficulty" class="px-3 py-2 rounded border-2 border-dark/30 focus:outline-none focus:border-primary">
                <option value="easy">ç®€å• (8x8)</option>
                <option value="medium" selected>ä¸­ç­‰ (14x14)</option>
                <option value="hard">å›°éš¾ (20x20)</option>
                <option value="insane">è¶…éš¾ (26x26)</option>
            </select>
        </div>
        <button id="resetBtn" class="bg-primary text-white px-6 py-3 rounded-lg font-bold btn-shadow hover:bg-primary/90 transition-all active:btn-active">
            <i class="fa fa-refresh mr-2"></i>é‡æ–°å¼€å§‹
        </button>
        <div class="bg-white/80 rounded-lg p-3 shadow-md">
            <span class="font-bold">è®¡æ—¶ï¼š</span>
            <span id="timer" class="text-primary font-bold">00:00</span>
        </div>
        <div class="bg-white/80 rounded-lg p-3 shadow-md hidden md:block">
            <span class="font-bold">æ­¥æ•°ï¼š</span>
            <span id="stepCounter" class="text-obstacle font-bold">0</span>
        </div>
    </div>

    <!-- æ¸¸æˆä¸»å®¹å™¨ -->
    <div class="relative bg-dark/10 rounded-2xl p-4 shadow-xl mb-6">
        <canvas id="mazeCanvas" class="rounded-xl bg-white shadow-inner"></canvas>
        <!-- é€šå…³æç¤º -->
        <div id="successModal" class="hidden absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-white/95 p-8 rounded-2xl shadow-2xl text-center z-10">
            <h2 class="text-[clamp(1.5rem,3vw,2rem)] text-primary font-bold mb-4">ğŸ‰ æ­å–œé€šå…³ï¼ ğŸ‰</h2>
            <p class="text-dark mb-3" id="successTime">ä½ ç”¨äº†XXç§’å®Œæˆè¿·å®«ï¼</p>
            <p class="text-dark mb-6" id="successStep">ä½ èµ°äº†XXæ­¥ï¼</p>
            <button id="playAgainBtn" class="bg-secondary text-white px-6 py-3 rounded-lg font-bold btn-shadow hover:bg-secondary/90 transition-all active:btn-active">
                <i class="fa fa-play mr-2"></i>å†ç©ä¸€æ¬¡
            </button>
        </div>
    </div>

    <!-- ç§»åŠ¨ç«¯è™šæ‹Ÿæ–¹å‘é”® -->
    <div class="md:hidden flex flex-col items-center gap-3 w-full max-w-xs mb-6">
        <button id="upBtn" class="bg-primary/90 text-white w-16 h-16 rounded-full flex items-center justify-center text-2xl shadow-lg hover:bg-primary active:scale-95 transition-all">
            <i class="fa fa-arrow-up"></i>
        </button>
        <div class="flex gap-3">
            <button id="leftBtn" class="bg-primary/90 text-white w-16 h-16 rounded-full flex items-center justify-center text-2xl shadow-lg hover:bg-primary active:scale-95 transition-all">
                <i class="fa fa-arrow-left"></i>
            </button>
            <button id="downBtn" class="bg-primary/90 text-white w-16 h-16 rounded-full flex items-center justify-center text-2xl shadow-lg hover:bg-primary active:scale-95 transition-all">
                <i class="fa fa-arrow-down"></i>
            </button>
            <button id="rightBtn" class="bg-primary/90 text-white w-16 h-16 rounded-full flex items-center justify-center text-2xl shadow-lg hover:bg-primary active:scale-95 transition-all">
                <i class="fa fa-arrow-right"></i>
            </button>
        </div>
        <!-- ç§»åŠ¨ç«¯æ­¥æ•°æ˜¾ç¤º -->
        <div class="bg-white/80 rounded-lg p-3 shadow-md mt-3 w-full text-center">
            <span class="font-bold">æ­¥æ•°ï¼š</span>
            <span id="mobileStepCounter" class="text-obstacle font-bold">0</span>
        </div>
    </div>

    <!-- æ¸¸æˆè¯´æ˜ -->
    <div class="bg-white/80 rounded-lg p-4 shadow-md w-full max-w-3xl text-sm md:text-base">
        <h3 class="font-bold text-primary mb-2">æ¸¸æˆè¯´æ˜</h3>
        <ul class="list-disc list-inside text-dark/80 space-y-1">
            <li>ä½¿ç”¨<span class="font-bold">é”®ç›˜æ–¹å‘é”®</span>æˆ–<span class="font-bold">å±å¹•è™šæ‹ŸæŒ‰é’®</span>ç§»åŠ¨å°ç¬‘è„¸</li>
            <li>ä»å·¦ä¸Šè§’çš„èµ·ç‚¹å‡ºå‘ï¼Œåˆ°è¾¾å³ä¸‹è§’çš„å‡ºå£å³å¯é€šå…³</li>
            <li>éš¾åº¦è¶Šé«˜ï¼Œè¿·å®«è¶Šå¤æ‚ï¼Œè¿˜ä¼šå‡ºç°<span class="text-obstacle font-bold">æ©™è‰²éšœç¢ç‰©</span>å’Œè§†è§‰å¹²æ‰°</li>
            <li>è¶…éš¾æ¨¡å¼ä¸‹ï¼Œè§’è‰²<span class="font-bold">æ— æ³•å¾€å›èµ°</span>ï¼ˆç¦æ­¢ä¸€æ­¥è¿”å›ï¼‰</li>
        </ul>
    </div>

    <script>
        // æ¸¸æˆæ ¸å¿ƒå˜é‡
        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');
        const difficultySelect = document.getElementById('difficulty');
        const resetBtn = document.getElementById('resetBtn');
        const timerEl = document.getElementById('timer');
        const stepCounter = document.getElementById('stepCounter');
        const mobileStepCounter = document.getElementById('mobileStepCounter');
        const successModal = document.getElementById('successModal');
        const successTime = document.getElementById('successTime');
        const successStep = document.getElementById('successStep');
        const playAgainBtn = document.getElementById('playAgainBtn');
        const difficultyTip = document.getElementById('difficultyTip');
        const directionBtns = {
            up: document.getElementById('upBtn'),
            down: document.getElementById('downBtn'),
            left: document.getElementById('leftBtn'),
            right: document.getElementById('rightBtn')
        };

        // è¿·å®«é…ç½® - å‡çº§åå¢åŠ æ›´å¤šå‚æ•°
        let mazeConfig = {
            cellSize: 35,    // ç¼©å°æ ¼å­å¤§å°ï¼Œé€‚é…æ›´å¤§çš„è¿·å®«
            cols: 14,        // åˆ—æ•°ï¼ˆé»˜è®¤ä¸­ç­‰éš¾åº¦ï¼‰
            rows: 14,        // è¡Œæ•°
            maze: [],        // è¿·å®«æ•°æ®ï¼ˆ0=é€šè·¯ï¼Œ1=å¢™å£ï¼Œ2=éšœç¢ç‰©ï¼‰
            player: { x: 1, y: 1 }, // ç©å®¶ä½ç½®
            end: { x: 0, y: 0 },    // ç»ˆç‚¹ä½ç½®
            isPlaying: false,       // æ¸¸æˆæ˜¯å¦è¿›è¡Œä¸­
            startTime: 0,           // å¼€å§‹æ—¶é—´
            timerInterval: null,    // è®¡æ—¶å®šæ—¶å™¨
            elapsedTime: 0,         // å·²ç”¨æ—¶é—´
            stepCount: 0,           // ç§»åŠ¨æ­¥æ•°
            lastDir: null,          // ä¸Šä¸€æ¬¡ç§»åŠ¨æ–¹å‘ï¼ˆè¶…éš¾æ¨¡å¼é™åˆ¶ï¼‰
            difficulty: 'medium',   // å½“å‰éš¾åº¦
            hasObstacle: false,     // æ˜¯å¦ç”Ÿæˆéšœç¢ç‰©
            visionWeak: false       // æ˜¯å¦å¼€å¯è§†è§‰å¼±åŒ–
        };

        // éš¾åº¦é…ç½®æ˜ å°„ - å‡çº§åå¢åŠ è¶…éš¾éš¾åº¦ï¼Œæ–°å¢éšœç¢ç‰©ã€è§†è§‰ã€ç§»åŠ¨é™åˆ¶
        const difficultyMap = {
            easy: { 
                cols: 8, rows: 8, 
                tip: 'ç®€å• - å°è¿·å®«ï¼Œæ— éšœç¢ç‰©ï¼Œæ— é™åˆ¶',
                obstacle: false, visionWeak: false, backLimit: false 
            },
            medium: { 
                cols: 14, rows: 14, 
                tip: 'ä¸­ç­‰ - æ™®é€šè¿·å®«ï¼Œæ— éšœç¢ç‰©ï¼Œæ— é™åˆ¶',
                obstacle: false, visionWeak: false, backLimit: false 
            },
            hard: { 
                cols: 20, rows: 20, 
                tip: 'å›°éš¾ - å¤§è¿·å®«ï¼Œæœ‰æ©™è‰²éšœç¢ç‰©ï¼Œè§†è§‰è½»å¾®å¼±åŒ–',
                obstacle: true, visionWeak: true, backLimit: false 
            },
            insane: { 
                cols: 26, rows: 26, 
                tip: 'è¶…éš¾ - è¶…å¤§è¿·å®«ï¼Œå¤šéšœç¢ç‰©ï¼Œè§†è§‰å¼±åŒ–ï¼Œç¦æ­¢ä¸€æ­¥è¿”å›',
                obstacle: true, visionWeak: true, backLimit: true 
            }
        };

        // æ–¹å‘æ˜ å°„ï¼ˆç”¨äºè¶…éš¾æ¨¡å¼çš„è¿”å›é™åˆ¶ï¼‰
        const dirOpposite = {
            up: 'down',
            down: 'up',
            left: 'right',
            right: 'left',
            null: null
        };

        // åˆå§‹åŒ–ç”»å¸ƒå¤§å°
        function initCanvas() {
            const { cols, rows, cellSize } = mazeConfig;
            canvas.width = cols * cellSize;
            canvas.height = rows * cellSize;
            // æ ¹æ®éš¾åº¦è®¾ç½®è§†è§‰æ•ˆæœ
            if (mazeConfig.visionWeak) {
                canvas.classList.add('vision-weak');
            } else {
                canvas.classList.remove('vision-weak');
            }
        }

        // ç”Ÿæˆéšæœºè¿·å®« - å‡çº§åå¢åŠ éšœç¢ç‰©ç”Ÿæˆé€»è¾‘ï¼Œæå‡è¿·å®«å¤æ‚åº¦
        function generateMaze() {
            const { cols, rows, hasObstacle } = mazeConfig;
            // åˆå§‹åŒ–è¿·å®«ï¼šå…¨éƒ¨è®¾ä¸ºå¢™å£
            const maze = Array(rows).fill().map(() => Array(cols).fill(1));
            const stack = [];
            
            // èµ·ç‚¹è®¾ä¸ºé€šè·¯ï¼ˆå·¦ä¸Šè§’ï¼Œé¿å¼€è¾¹ç•Œï¼‰
            const startX = 1;
            const startY = 1;
            maze[startY][startX] = 0;
            stack.push({ x: startX, y: startY });

            // æ–¹å‘ï¼šä¸Šã€å³ã€ä¸‹ã€å·¦ï¼ˆå¢åŠ éšæœºæƒé‡ï¼Œæå‡å¤æ‚åº¦ï¼‰
            const directions = [
                { dx: 0, dy: -2, dir: 'up' }, // ä¸Š
                { dx: 2, dy: 0, dir: 'right' },  // å³
                { dx: 0, dy: 2, dir: 'down' },  // ä¸‹
                { dx: -2, dy: 0, dir: 'left' }  // å·¦
            ];

            // é€’å½’å›æº¯æŒ–è·¯ - ä¼˜åŒ–éšæœºé€»è¾‘ï¼Œè®©è¿·å®«æ›´å¤æ‚
            while (stack.length > 0) {
                const current = stack.pop();
                // éšæœºæ‰“ä¹±æ–¹å‘ï¼Œå¢åŠ è¿·å®«çš„ä¸è§„åˆ™æ€§
                const shuffledDirs = [...directions].sort(() => Math.random() - 0.5);
                let hasNext = false;

                for (const dir of shuffledDirs) {
                    const newX = current.x + dir.dx;
                    const newY = current.y + dir.dy;
                    // æ£€æŸ¥æ˜¯å¦åœ¨è¿·å®«èŒƒå›´å†…ä¸”æœªè¢«è®¿é—®
                    if (newX > 0 && newX < cols - 1 && newY > 0 && newY < rows - 1 && maze[newY][newX] === 1) {
                        // æŒ–é€šå½“å‰æ ¼å­å’Œæ–°æ ¼å­ä¹‹é—´çš„å¢™å£
                        maze[current.y + dir.dy/2][current.x + dir.dx/2] = 0;
                        maze[newY][newX] = 0;
                        stack.push(current);
                        stack.push({ x: newX, y: newY });
                        hasNext = true;
                        break;
                    }
                }

                // å¢åŠ æ­»èƒ¡åŒçš„æ¦‚ç‡ï¼Œæå‡è¿·å®«å¤æ‚åº¦
                if (!hasNext && stack.length > 0) {
                    const randomDir = directions[Math.floor(Math.random() * directions.length)];
                    const newX = current.x + randomDir.dx;
                    const newY = current.y + randomDir.dy;
                    if (newX > 0 && newX < cols - 1 && newY > 0 && newY < rows - 1) {
                        maze[newY][newX] = 1;
                    }
                }
            }

            // ç”Ÿæˆéšœç¢ç‰©ï¼ˆå›°éš¾/è¶…éš¾æ¨¡å¼ï¼‰
            if (hasObstacle) {
                const obstacleCount = Math.floor((cols * rows) / 25); // æ ¹æ®è¿·å®«å¤§å°è®¡ç®—éšœç¢ç‰©æ•°é‡
                for (let i = 0; i < obstacleCount; i++) {
                    const obsX = Math.floor(Math.random() * (cols - 2)) + 1;
                    const obsY = Math.floor(Math.random() * (rows - 2)) + 1;
                    // é¿å¼€èµ·ç‚¹ã€ç»ˆç‚¹å’Œé€šè·¯çš„å…³é”®ä½ç½®
                    if ((obsX !== startX || obsY !== startY) && maze[obsY][obsX] === 0) {
                        maze[obsY][obsX] = 2;
                    }
                }
            }

            // è®¾ç½®ç»ˆç‚¹ï¼ˆå³ä¸‹è§’ï¼Œç¡®ä¿æ˜¯é€šè·¯ï¼‰
            let endX = cols - 2;
            let endY = rows - 2;
            if (maze[endY][endX] !== 0) {
                // å¦‚æœç»ˆç‚¹æ˜¯å¢™å£/éšœç¢ç‰©ï¼Œæ‰¾é™„è¿‘çš„é€šè·¯
                for (let x = cols - 2; x > 0; x--) {
                    for (let y = rows - 2; y > 0; y--) {
                        if (maze[y][x] === 0) {
                            endX = x;
                            endY = y;
                            break;
                        }
                    }
                    if (maze[endY][endX] === 0) break;
                }
            }

            mazeConfig.maze = maze;
            mazeConfig.player = { x: startX, y: startY };
            mazeConfig.end = { x: endX, y: endY };
            mazeConfig.lastDir = null; // é‡ç½®ä¸Šä¸€æ¬¡æ–¹å‘
        }

        // ç»˜åˆ¶è¿·å®« - å‡çº§åå¢åŠ éšœç¢ç‰©ã€ä¼˜åŒ–è§†è§‰æ•ˆæœ
        function drawMaze() {
            const { maze, cellSize, player, end } = mazeConfig;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ç»˜åˆ¶è¿·å®«æ ¼å­
            maze.forEach((row, y) => {
                row.forEach((cell, x) => {
                    if (cell === 1) {
                        // ç»˜åˆ¶å¢™å£
                        ctx.fillStyle = '#1A535C';
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    } else if (cell === 2) {
                        // ç»˜åˆ¶éšœç¢ç‰©ï¼ˆæ©™è‰²ï¼‰
                        ctx.fillStyle = '#FF9F1C';
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                        // éšœç¢ç‰©è£…é¥°
                        ctx.fillStyle = '#E76F51';
                        ctx.beginPath();
                        ctx.arc(x * cellSize + cellSize/2, y * cellSize + cellSize/2, cellSize/6, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        // ç»˜åˆ¶é€šè·¯èƒŒæ™¯ï¼ˆæ ¹æ®è§†è§‰å¼±åŒ–è°ƒæ•´é¢œè‰²ï¼‰
                        ctx.fillStyle = mazeConfig.visionWeak ? '#F0F8F0' : '#F7FFF7';
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                        // ç»˜åˆ¶æ ¼å­è¾¹æ¡†ï¼ˆæµ…è‰²ï¼‰
                        ctx.strokeStyle = mazeConfig.visionWeak ? '#D6D6D6' : '#E6E6E6';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    }
                });
            });

            // ç»˜åˆ¶ç»ˆç‚¹ï¼ˆä¼˜åŒ–æ ·å¼ï¼‰
            ctx.fillStyle = '#4ECDC4';
            ctx.beginPath();
            ctx.arc(end.x * cellSize + cellSize/2, end.y * cellSize + cellSize/2, cellSize/3, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#1A535C';
            ctx.lineWidth = 2;
            ctx.stroke();
            // ç»ˆç‚¹è£…é¥°
            ctx.fillStyle = '#F7FFF7';
            ctx.beginPath();
            ctx.arc(end.x * cellSize + cellSize/2, end.y * cellSize + cellSize/2, cellSize/6, 0, Math.PI * 2);
            ctx.fill();

            // ç»˜åˆ¶ç©å®¶ï¼ˆç¬‘è„¸ï¼Œä¼˜åŒ–æ ·å¼ï¼‰
            ctx.fillStyle = '#FF6B6B';
            ctx.beginPath();
            ctx.arc(player.x * cellSize + cellSize/2, player.y * cellSize + cellSize/2, cellSize/3, 0, Math.PI * 2);
            ctx.fill();
            // ç»˜åˆ¶ç¬‘è„¸çœ¼ç›
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(player.x * cellSize + cellSize/3, player.y * cellSize + cellSize/3, cellSize/10, 0, Math.PI * 2);
            ctx.arc(player.x * cellSize + 2*cellSize/3, player.y * cellSize + cellSize/3, cellSize/10, 0, Math.PI * 2);
            ctx.fill();
            // ç»˜åˆ¶ç¬‘è„¸å˜´å·´
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(player.x * cellSize + cellSize/2, player.y * cellSize + cellSize/2, cellSize/4, 0, Math.PI);
            ctx.stroke();
        }

        // ç§»åŠ¨ç©å®¶ - å‡çº§åå¢åŠ æ­¥æ•°ç»Ÿè®¡ã€è¶…éš¾æ¨¡å¼è¿”å›é™åˆ¶ã€éšœç¢ç‰©æ£€æµ‹
        function movePlayer(dx, dy, dirName) {
            if (!mazeConfig.isPlaying) return;

            const { maze, player, difficulty, lastDir, backLimit } = mazeConfig;
            const diffConfig = difficultyMap[difficulty];
            
            // è¶…éš¾æ¨¡å¼ï¼šç¦æ­¢ä¸€æ­¥è¿”å›ï¼ˆå¾€ç›¸åæ–¹å‘ç§»åŠ¨ï¼‰
            if (diffConfig.backLimit && dirOpposite[lastDir] === dirName) {
                return;
            }

            const newX = player.x + dx;
            const newY = player.y + dy;
            // æ£€æŸ¥æ˜¯å¦æ˜¯å¢™å£ã€éšœç¢ç‰©æˆ–è¾¹ç•Œ
            if (newX >= 0 && newX < mazeConfig.cols && newY >= 0 && newY < mazeConfig.rows && maze[newY][newX] === 0) {
                mazeConfig.player.x = newX;
                mazeConfig.player.y = newY;
                mazeConfig.stepCount++; // ç»Ÿè®¡æ­¥æ•°
                mazeConfig.lastDir = dirName; // è®°å½•å½“å‰æ–¹å‘
                // æ›´æ–°æ­¥æ•°æ˜¾ç¤º
                stepCounter.textContent = mazeConfig.stepCount;
                mobileStepCounter.textContent = mazeConfig.stepCount;
                drawMaze();
                // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾ç»ˆç‚¹
                checkWin();
            }
        }

        // æ£€æŸ¥æ˜¯å¦é€šå…³
        function checkWin() {
            const { player, end, isPlaying, elapsedTime, stepCount } = mazeConfig;
            if (player.x === end.x && player.y === end.y && isPlaying) {
                // åœæ­¢è®¡æ—¶
                clearInterval(mazeConfig.timerInterval);
                mazeConfig.isPlaying = false;
                // æ˜¾ç¤ºé€šå…³æç¤º
                successTime.textContent = `ä½ ç”¨äº†${Math.round(elapsedTime)}ç§’å®Œæˆè¿·å®«ï¼`;
                successStep.textContent = `ä½ èµ°äº†${stepCount}æ­¥ï¼`;
                successModal.classList.remove('hidden');
            }
        }

        // æ ¼å¼åŒ–è®¡æ—¶ï¼ˆ00:00ï¼‰
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60).toString().padStart(2, '0');
            const secs = Math.floor(seconds % 60).toString().padStart(2, '0');
            return `${mins}:${secs}`;
        }

        // å¼€å§‹è®¡æ—¶
        function startTimer() {
            mazeConfig.startTime = Date.now();
            mazeConfig.timerInterval = setInterval(() => {
                mazeConfig.elapsedTime = (Date.now() - mazeConfig.startTime) / 1000;
                timerEl.textContent = formatTime(mazeConfig.elapsedTime);
            }, 100);
        }

        // é‡ç½®æ¸¸æˆ - å‡çº§åé€‚é…æ–°çš„éš¾åº¦é…ç½®
        function resetGame() {
            // åœæ­¢ç°æœ‰è®¡æ—¶
            if (mazeConfig.timerInterval) clearInterval(mazeConfig.timerInterval);
            // æ›´æ–°éš¾åº¦é…ç½®
            const difficulty = difficultySelect.value;
            const diffConfig = difficultyMap[difficulty];
            mazeConfig.difficulty = difficulty;
            mazeConfig.cols = diffConfig.cols;
            mazeConfig.rows = diffConfig.rows;
            mazeConfig.hasObstacle = diffConfig.obstacle;
            mazeConfig.visionWeak = diffConfig.visionWeak;
            // æ›´æ–°éš¾åº¦æç¤º
            difficultyTip.textContent = diffConfig.tip;
            // é‡æ–°åˆå§‹åŒ–ç”»å¸ƒå’Œç”Ÿæˆè¿·å®«
            initCanvas();
            generateMaze();
            drawMaze();
            // é‡ç½®è®¡æ—¶å’Œæ­¥æ•°
            mazeConfig.elapsedTime = 0;
            mazeConfig.stepCount = 0;
            timerEl.textContent = '00:00';
            stepCounter.textContent = '0';
            mobileStepCounter.textContent = '0';
            // éšè—é€šå…³æç¤º
            successModal.classList.add('hidden');
            // å¼€å§‹æ¸¸æˆ
            mazeConfig.isPlaying = true;
            startTimer();
        }

        // äº‹ä»¶ç›‘å¬ï¼šé”®ç›˜æ–¹å‘é”® - å‡çº§åä¼ é€’æ–¹å‘åç§°
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'ArrowUp': movePlayer(0, -1, 'up'); break;
                case 'ArrowDown': movePlayer(0, 1, 'down'); break;
                case 'ArrowLeft': movePlayer(-1, 0, 'left'); break;
                case 'ArrowRight': movePlayer(1, 0, 'right'); break;
            }
        });

        // äº‹ä»¶ç›‘å¬ï¼šè™šæ‹Ÿæ–¹å‘é”® - å‡çº§åä¼ é€’æ–¹å‘åç§°
        directionBtns.up.addEventListener('click', () => movePlayer(0, -1, 'up'));
        directionBtns.down.addEventListener('click', () => movePlayer(0, 1, 'down'));
        directionBtns.left.addEventListener('click', () => movePlayer(-1, 0, 'left'));
        directionBtns.right.addEventListener('click', () => movePlayer(1, 0, 'right'));

        // äº‹ä»¶ç›‘å¬ï¼šé‡ç½®æŒ‰é’®å’Œå†æ¥ä¸€æ¬¡æŒ‰é’®
        resetBtn.addEventListener('click', resetGame);
        playAgainBtn.addEventListener('click', resetGame);

        // äº‹ä»¶ç›‘å¬ï¼šéš¾åº¦é€‰æ‹©å˜åŒ–ï¼ˆæ›´æ–°æç¤ºï¼‰
        difficultySelect.addEventListener('change', () => {
            const diffConfig = difficultyMap[difficultySelect.value];
            difficultyTip.textContent = diffConfig.tip;
        });

        // åˆå§‹åŒ–æ¸¸æˆ
        window.addEventListener('load', () => {
            resetGame();
        });
    </script>
</body>
</html>
